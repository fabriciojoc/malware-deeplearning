import re
import csv
import os
import numpy as np
import math
import random

# All features available
FEATURES = [ "BaseOfCode", "BaseOfData", "Characteristics",
             "DllCharacteristics", "Entropy", "FileAlignment", "FileType", "FormatedTimeDateSteamp", "Fuzzy", "Identify", "ImageBase", "ImportedDlls", "ImportedSymbols", "MD5", "Machine", "Magic", "Name", "NumberOfRvaAndSizes", "NumberOfSections", "NumberOfSymbols", "PE_TYPE", "PointerToSymbolTable", "SHA1", "Size", "SizeOfCode", "SizeOfHeaders", "SizeOfImage", "SizeOfInitializedData", "SizeOfOptionalHeader", "SizeOfUninitializedData", "TimeDateStamp"]

# Used features
USED_FEATURES = [ "BaseOfCode", "BaseOfData", "Characteristics",
                  "DllCharacteristics", "FileAlignment", "ImageBase", "NumberOfRvaAndSizes", "NumberOfSections", "NumberOfSymbols", "PointerToSymbolTable", "Size", "SizeOfCode", "SizeOfHeaders", "SizeOfImage", "SizeOfInitializedData",  "SizeOfUninitializedData", "TimeDateStamp"]


# given a text feature, clear it and return an array of texts
def clear_text(text):
    text = text.replace("'","").replace("[","").replace("]","")
    text = re.sub("[^A-Za-z0-9]+","", text)
    return text.lower()

# given a csv file, return its headers
def headers(input_file):
    headers = []
    for f in USED_FEATURES:
        headers.append(f)
    headers.append("Entropy")
    return headers

# given a csv file with malware and goodware features, return their features
# and textual attributes (identifiers, imported_dlls and imported_symbols)
def read_file(input_file):
    with open(input_file, 'rb') as file:
        reader = csv.DictReader(file)
        features = []
        identifiers = []
        imported_dlls = []
        imported_symbols = []
        for row in reader:
            example = []
            for f in USED_FEATURES:
                example.append(int(row[f]))
            example.append(float(row["Entropy"]))
            # get compiler and packer info
            id_regex = r"\[\'[^']*\'\]"
            ident = re.findall(id_regex,row["Identify"])
            identify = ""
            for i in ident:
                identify += clear_text(i) + " "
            # get imported dlls
            dll_regex = r"\'[^']*\'"
            i_dlls = re.findall(dll_regex,row["ImportedDlls"])
            dlls = ""
            for d in i_dlls:
                dlls += clear_text(d) + " "
            # get imported symbols
            i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
            symbols = ""
            for d in i_symbols:
                symbols += clear_text(d) + " "
            # apped texts to their arrays
            identifiers.append(identify)
            imported_dlls.append(dlls)
            imported_symbols.append(symbols)
            # append current example features
            features.append(example)
    features = np.array(features)
    identifiers = np.array(identifiers)
    imported_dlls = np.array(imported_dlls)
    imported_symbols = np.array(imported_symbols)
    return features, identifiers, imported_dlls, imported_symbols


# read samples and keep <=max_year as train and above, as test
def read_year(input_file, max_year=2014):
    with open(input_file, 'rb') as file:
        reader = csv.DictReader(file)
        # train <= max_year
        train_features = []
        train_identifiers = []
        train_imported_dlls = []
        train_imported_symbols = []
        # test > max_year
        test_features = []
        test_identifiers = []
        test_imported_dlls = []
        test_imported_symbols = []
        for row in reader:
            example = []
            for f in USED_FEATURES:
                example.append(int(row[f]))
            example.append(float(row["Entropy"]))
            # get compiler and packer info
            id_regex = r"\[\'[^']*\'\]"
            ident = re.findall(id_regex,row["Identify"])
            identify = ""
            for i in ident:
                identify += clear_text(i) + " "
            # get imported dlls
            dll_regex = r"\'[^']*\'"
            i_dlls = re.findall(dll_regex,row["ImportedDlls"])
            dlls = ""
            for d in i_dlls:
                dlls += clear_text(d) + " "
            # get imported symbols
            i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
            symbols = ""
            for d in i_symbols:
                symbols += clear_text(d) + " "
            year = int(row["FormatedTimeDateStamp"].split('-')[0])
            if year <= max_year:
                # append current example features
                train_features.append(example)
                # apped texts to their arrays
                train_identifiers.append(identify)
                train_imported_dlls.append(dlls)
                train_imported_symbols.append(symbols)
            else:
                # append current example features
                test_features.append(example)
                # apped texts to their arrays
                test_identifiers.append(identify)
                test_imported_dlls.append(dlls)
                test_imported_symbols.append(symbols)
    train_features = np.array(train_features)
    train_identifiers = np.array(train_identifiers)
    train_imported_dlls = np.array(train_imported_dlls)
    train_imported_symbols = np.array(train_imported_symbols)
    test_features = np.array(test_features)
    test_identifiers = np.array(test_identifiers)
    test_imported_dlls = np.array(test_imported_dlls)
    test_imported_symbols = np.array(test_imported_symbols)
    return train_features, train_identifiers, train_imported_dlls, train_imported_symbols, test_features, test_identifiers, test_imported_dlls, test_imported_symbols

# given a csv, collect items from a certain month and year only
def read_csv_month_year(input_file, month, year):
    with open(input_file, 'rb') as file:
        reader = csv.DictReader(file)
        features = []
        identifiers = []
        imported_dlls = []
        imported_symbols = []
        for row in reader:
            sample_year = int(row["FormatedTimeDateStamp"].split('-')[0])
            sample_month = int(row["FormatedTimeDateStamp"].split('-')[1])
            if year==sample_year and month==sample_month:
                # print month, year
                example = []
                for f in USED_FEATURES:
                    example.append(int(row[f]))
                example.append(float(row["Entropy"]))
                # get compiler and packer info
                id_regex = r"\[\'[^']*\'\]"
                ident = re.findall(id_regex,row["Identify"])
                identify = ""
                for i in ident:
                    identify += clear_text(i) + " "
                # get imported dlls
                dll_regex = r"\'[^']*\'"
                i_dlls = re.findall(dll_regex,row["ImportedDlls"])
                dlls = ""
                for d in i_dlls:
                    dlls += clear_text(d) + " "
                # get imported symbols
                i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
                symbols = ""
                for d in i_symbols:
                    symbols += clear_text(d) + " "
                # append current example features
                features.append(example)
                # apped texts to their arrays
                identifiers.append(identify)
                imported_dlls.append(dlls)
                imported_symbols.append(symbols)
    features = np.array(features)
    identifiers = np.array(identifiers)
    imported_dlls = np.array(imported_dlls)
    imported_symbols = np.array(imported_symbols)
    return features, identifiers, imported_dlls, imported_symbols

# given a csv, collect items until a certain month and year only cumulative
def read_csv_month_year_cumulative(input_file, month, year):
    with open(input_file, 'rb') as file:
        reader = csv.DictReader(file)
        features = []
        identifiers = []
        imported_dlls = []
        imported_symbols = []
        for row in reader:
            sample_year = int(row["FormatedTimeDateStamp"].split('-')[0])
            sample_month = int(row["FormatedTimeDateStamp"].split('-')[1])
            if (sample_year<year) or (sample_year==year and sample_month<=month):
                # print month, year
                example = []
                for f in USED_FEATURES:
                    example.append(int(row[f]))
                example.append(float(row["Entropy"]))
                # get compiler and packer info
                id_regex = r"\[\'[^']*\'\]"
                ident = re.findall(id_regex,row["Identify"])
                identify = ""
                for i in ident:
                    identify += clear_text(i) + " "
                # get imported dlls
                dll_regex = r"\'[^']*\'"
                i_dlls = re.findall(dll_regex,row["ImportedDlls"])
                dlls = ""
                for d in i_dlls:
                    dlls += clear_text(d) + " "
                # get imported symbols
                i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
                symbols = ""
                for d in i_symbols:
                    symbols += clear_text(d) + " "
                # append current example features
                features.append(example)
                # apped texts to their arrays
                identifiers.append(identify)
                imported_dlls.append(dlls)
                imported_symbols.append(symbols)
    features = np.array(features)
    identifiers = np.array(identifiers)
    imported_dlls = np.array(imported_dlls)
    imported_symbols = np.array(imported_symbols)
    return features, identifiers, imported_dlls, imported_symbols

# read csv fles in the format "year-month-day.csv"
def read_month_year(location, month, year):
    features = []
    identifiers = []
    imported_dlls = []
    imported_symbols = []
    hashes=[]
    for root, dirs, files in os.walk(location):
        for f in sorted(files):
            if f.endswith(".csv"):
                sample_year = int(f.split("-")[0])
                sample_month = int(f.split("-")[1])
                if year==sample_year and month==sample_month:
                    file_loc = os.path.join(root, f)
                    # print file_loc
                    with open(file_loc, 'rb') as file:
                        reader = csv.DictReader(file)
                        for row in reader:
                            # remove duplicated samples
                            if row['MD5'] not in hashes:
                                example = []
                                for f in USED_FEATURES:
                                    example.append(int(row[f]))
                                example.append(float(row["Entropy"]))
                                # get compiler and packer info
                                id_regex = r"\[\'[^']*\'\]"
                                ident = re.findall(id_regex,row["Identify"])
                                identify = ""
                                for i in ident:
                                    identify += clear_text(i) + " "
                                # get imported dlls
                                dll_regex = r"\'[^']*\'"
                                i_dlls = re.findall(dll_regex,row["ImportedDlls"])
                                dlls = ""
                                for d in i_dlls:
                                    dlls += clear_text(d) + " "
                                # get imported symbols
                                i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
                                symbols = ""
                                for d in i_symbols:
                                    symbols += clear_text(d) + " "
                                # append current example features
                                features.append(example)
                                # apped texts to their arrays
                                identifiers.append(identify)
                                imported_dlls.append(dlls)
                                imported_symbols.append(symbols)
                                hashes.append(row['MD5'])
    features = np.array(features)
    identifiers = np.array(identifiers)
    imported_dlls = np.array(imported_dlls)
    imported_symbols = np.array(imported_symbols)
    return features, identifiers, imported_dlls, imported_symbols

# read csv files in a folder in the format "year-month-day.csv" and return all programs
def read_ymd_csvs(location):
    features = []
    identifiers = []
    imported_dlls = []
    imported_symbols = []
    hashes=[]
    years = {}
    for root, dirs, files in os.walk(location):
        for f in sorted(files):
            if f.endswith(".csv"):
                sample_year = int(f.split("-")[0])
                file_loc = os.path.join(root, f)
                # print file_loc
                with open(file_loc, 'rb') as file:
                    reader = csv.DictReader(file)
                    for row in reader:
                        # remove duplicated samples
                        if row['MD5'] not in hashes:
                            if sample_year in years.keys():
                                years[sample_year]=years[sample_year]+1
                            else:
                                years[sample_year]=1
                            example = []
                            for f in USED_FEATURES:
                                example.append(int(row[f]))
                            example.append(float(row["Entropy"]))
                            # get compiler and packer info
                            id_regex = r"\[\'[^']*\'\]"
                            ident = re.findall(id_regex,row["Identify"])
                            identify = ""
                            for i in ident:
                                identify += clear_text(i) + " "
                            # get imported dlls
                            dll_regex = r"\'[^']*\'"
                            i_dlls = re.findall(dll_regex,row["ImportedDlls"])
                            dlls = ""
                            for d in i_dlls:
                                dlls += clear_text(d) + " "
                            # get imported symbols
                            i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
                            symbols = ""
                            for d in i_symbols:
                                symbols += clear_text(d) + " "
                            # append current example features
                            features.append(example)
                            # apped texts to their arrays
                            identifiers.append(identify)
                            imported_dlls.append(dlls)
                            imported_symbols.append(symbols)
                            hashes.append(row['MD5'])
    features = np.array(features)
    identifiers = np.array(identifiers)
    imported_dlls = np.array(imported_dlls)
    imported_symbols = np.array(imported_symbols)
    return features, identifiers, imported_dlls, imported_symbols, years

# read csv fles in the format "year-month-day.csv" cumulating samples
def read_month_year_cumulative(location, month, year):
    features = []
    identifiers = []
    imported_dlls = []
    imported_symbols = []
    hashes=[]
    for root, dirs, files in os.walk(location):
        for f in sorted(files):
            if f.endswith(".csv"):
                sample_year = int(f.split("-")[0])
                sample_month = int(f.split("-")[1])
                if (sample_year<year) or (sample_year==year and sample_month<=month):
                    file_loc = os.path.join(root, f)
                    # print file_loc
                    with open(file_loc, 'rb') as file:
                        reader = csv.DictReader(file)
                        for row in reader:
                            # remove duplicated samples
                            if row['MD5'] not in hashes:
                                example = []
                                for f in USED_FEATURES:
                                    example.append(int(row[f]))
                                example.append(float(row["Entropy"]))
                                # get compiler and packer info
                                id_regex = r"\[\'[^']*\'\]"
                                ident = re.findall(id_regex,row["Identify"])
                                identify = ""
                                for i in ident:
                                    identify += clear_text(i) + " "
                                # get imported dlls
                                dll_regex = r"\'[^']*\'"
                                i_dlls = re.findall(dll_regex,row["ImportedDlls"])
                                dlls = ""
                                for d in i_dlls:
                                    dlls += clear_text(d) + " "
                                # get imported symbols
                                i_symbols = re.findall(dll_regex,row["ImportedSymbols"])
                                symbols = ""
                                for d in i_symbols:
                                    symbols += clear_text(d) + " "
                                # append current example features
                                features.append(example)
                                # apped texts to their arrays
                                identifiers.append(identify)
                                imported_dlls.append(dlls)
                                imported_symbols.append(symbols)
                                hashes.append(row['MD5'])
    features = np.array(features)
    identifiers = np.array(identifiers)
    imported_dlls = np.array(imported_dlls)
    imported_symbols = np.array(imported_symbols)
    return features, identifiers, imported_dlls, imported_symbols

# read csv fles in the format "year-month-day.csv" and return features only
def read_features_month_year(location, month, year):
    features = []
    hashes=[]
    for root, dirs, files in os.walk(location):
        for f in sorted(files):
            if f.endswith(".csv"):
                sample_year = int(f.split("-")[0])
                sample_month = int(f.split("-")[1])
                if year==sample_year and month==sample_month:
                    file_loc = os.path.join(root, f)
                    # print file_loc
                    with open(file_loc, 'rb') as file:
                        reader = csv.DictReader(file)
                        for row in reader:
                            # remove duplicated samples
                            if row['MD5'] not in hashes:
                                features.append(row)
                                hashes.append(row['MD5'])
    return features


# cross validation approach given a set of features, identifiers, dlls, symbols
# and their labels (with test_size)
def cross_validation(features, identifiers, dlls, symbols, labels, test_size):
    # total data
    n_data = len(features)
    # number of test data
    n_test = math.ceil(n_data*test_size)
    # get random n_test indexes
    indexes = random.sample(range(n_data), int(n_test))
    features_test = []
    features_train = []
    identifiers_test = []
    identifiers_train = []
    dlls_test = []
    dlls_train = []
    symbols_test = []
    symbols_train = []
    labels_test = []
    labels_train = []
    for i in range(len(features)):
        if i not in indexes:
            # add data i to train
            features_train.append(features[i])
            identifiers_train.append(identifiers[i])
            dlls_train.append(dlls[i])
            symbols_train.append(symbols[i])
            labels_train.append(labels[i])
        else:
            # add data i to test
            features_test.append(features[i])
            identifiers_test.append(identifiers[i])
            dlls_test.append(dlls[i])
            symbols_test.append(symbols[i])
            labels_test.append(labels[i])
    return features_train, features_test, identifiers_train, identifiers_test, dlls_train, dlls_test, symbols_train, symbols_test, labels_train, labels_test

# given a set of features, identifiers, dlls, symbols and labels, returns n
# random samples
def random_samples(features, identifiers, dlls, symbols, labels, n):
    # total data
    n_data = len(features)
    # get random n indexes
    indexes = random.sample(range(n_data), int(n))
    features_out = []
    identifiers_out = []
    dlls_out = []
    symbols_out = []
    labels_out = []
    for i in range(n_data):
        if i in indexes:
            # add data i to batch
            features_out.append(features[i])
            identifiers_out.append(identifiers[i])
            dlls_out.append(dlls[i])
            symbols_out.append(symbols[i])
            labels_out.append(labels[i])
    return features_out, identifiers_out, dlls_out, symbols_out, labels_out

# concatenate features with features in an array
def concatenate_features(features, array):
    X = []
    for i in range(features.shape[0]):
        x = features[i]
        for j in array:
            x = np.concatenate((x,j[i].toarray()[0]))
        X.append(x)
    return np.array(X)

def concatenate_features_w2v(features, array):
    X = []
    for i in range(features.shape[0]):
        x = features[i]
        for j in array:
            x = np.concatenate((x,j[i]))
        X.append(x)
    return np.array(X)

# creates an hot encoding array for a two-class problem
def hot_enconding(y):
    new_y = []
    for i in y:
        temp = np.zeros(2)
        temp[int(i)] = 1
        new_y.append(temp)
    return np.array(new_y)

# given a probability array, return the class most likely class
def prob_to_class(pred):
    new_pred = []
    for i in pred:
        temp = np.array(i).argsort()[::-1][0]
        new_pred.append(temp)
    return new_pred

# given a probability array, classify the example as 0 if threshold is smaller
# than its probability
def prob_to_class_threshold(pred, threshold):
    new_pred = []
    for i in pred:
        dist = i[np.array(i).argsort()[::-1][0]]
        if dist > threshold:
            temp = np.array(i).argsort()[::-1][0]
        else:
            temp = 0
        new_pred.append(temp)
    return new_pred
