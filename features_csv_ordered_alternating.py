# -*- coding: UTF-8 -*-.
import argparse
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import MinMaxScaler
import numpy as np
import sys
import csv
import os
import time
import re
from datetime import datetime
from operator import itemgetter
sys.path.append("./lib")
from common import read_file, cross_validation, hot_enconding, concatenate_features, concatenate_features_w2v, prob_to_class, prob_to_class_threshold, headers, random_samples, read_csv_month_year, read_month_year, read_ymd_csvs

USED_FEATURES = [ "BaseOfCode", "BaseOfData", "Characteristics", "DllCharacteristics", "FileAlignment", "ImageBase", "NumberOfRvaAndSizes", "NumberOfSections", "NumberOfSymbols", "PointerToSymbolTable", "Size", "SizeOfCode", "SizeOfHeaders", "SizeOfImage", "SizeOfInitializedData",  "SizeOfUninitializedData", "Entropy", "Identify", "ImportedDlls", "ImportedSymbols"]

NUMERICAL_FEATURES = [ "BaseOfCode", "BaseOfData", "Characteristics", "DllCharacteristics", "FileAlignment", "ImageBase", "NumberOfRvaAndSizes", "NumberOfSections", "NumberOfSymbols", "PointerToSymbolTable", "Size", "SizeOfCode", "SizeOfHeaders", "SizeOfImage", "SizeOfInitializedData",  "SizeOfUninitializedData", "Entropy"]

TEXTUAL_FEATURES = ["Identify", "ImportedDlls", "ImportedSymbols"]

# given a text feature, clear it and return an array of texts
def clear_text(text):
    text = text.replace("'","").replace("[","").replace("]","")
    text = re.sub("[^A-Za-z0-9]+","", text)
    return text.lower()


def params():
    parser = argparse.ArgumentParser()
    parser.add_argument('goodwares_csv', help='Goodwares CSV location')
    parser.add_argument('malwares_csv', help='Malwares CSV Location')
    params = parser.parse_args()
    return params.goodwares_csv, params.malwares_csv

# get params
gw_csv, mw_csv = params()

items = []

# get keys
k = []
for attr in USED_FEATURES:
    k.append(attr)
k.append("Time")
k.append("MD5")
k.append("FormatedTimeDateStamp")
k.append("Label")

# create md5 list
# md5s = []

# open goodware and append to items
with open(gw_csv, 'rb') as file:
    reader = csv.DictReader(file)
    for row in reader:
        # convert timestamp
        t = datetime.fromtimestamp(int(row["TimeDateStamp"]))
        tts = time.mktime(t.timetuple())
        # get values
        r = []
        for attr in USED_FEATURES:
            r.append(row[attr])
        # append timstamp and label (gw = 0)
        r.append(tts)
        r.append(row["MD5"])
        r.append(row["FormatedTimeDateStamp"])
        r.append(0)
        items.append(r)
        # md5s.append(row["MD5"])

# open malwares by day and append to items
for root, dirs, files in os.walk(mw_csv):
    for f in sorted(files):
        if f.endswith(".csv"):
            # get date and convert to timestamp
            date = f.replace(".csv","")
            t = datetime.strptime(date, "%Y-%m-%d")
            tts = time.mktime(t.timetuple())
            sample_year = int(f.split("-")[0])
            file_loc = os.path.join(root, f)
            with open(file_loc, 'rb') as file:
                reader = csv.DictReader(file)
                for row in reader:
                    # if row["MD5"] not in md5s:
                    # get values
                    r = []
                    for attr in USED_FEATURES:
                        r.append(row[attr])
                    # append timstamp and label (mw = 1)
                    r.append(tts)
                    r.append(row["MD5"])
                    r.append(row["FormatedTimeDateStamp"])
                    r.append(1)
                    items.append(r)
                    # md5s.append(row["MD5"])

# order by time
items_ordered = sorted(items, key=itemgetter(len(items[0])-4))

# write attributes csv
# csv_ordered = open('mw_attributes_full_sorted.csv', "a")
# c_ordered = csv.writer(csv_ordered)
# c_ordered.writerow(k)
# for i in items_ordered:
#     c_ordered.writerow(i)

# dlls and symbols indexes
i_dlls = len(items_ordered[0])-6
i_symbols = len(items_ordered[0])-5
i_time = len(items_ordered[0])-4
i_md5 = len(items_ordered[0])-3
i_ftime = len(items_ordered[0])-2
i_labels = len(items_ordered[0])-1

# separate examples features in categories
num_features = []
dlls_features = []
symbols_features = []
times = []
md5 = []
labels = []
# iterate over samples
for i in range(0,len(items_ordered)):
    f = []
    # append numerical features
    for j in range(0,i_dlls-1):
        f.append(items_ordered[i][j])
    f.append(items_ordered[i][i_time])
    # append textual features
    dll_regex = r"\'[^']*\'"
    idlls = re.findall(dll_regex,items_ordered[i][i_dlls])
    dlls = ""
    for d in idlls:
        dlls += clear_text(d) + " "
    isym = re.findall(dll_regex,items_ordered[i][i_symbols])
    sym = ""
    for d in isym:
        sym += clear_text(d) + " "
    num_features.append(f)
    dlls_features.append(dlls)
    symbols_features.append(sym)
    times.append(items_ordered[i][i_ftime])
    md5.append(items_ordered[i][i_md5])
    labels.append(items_ordered[i][i_labels])

labels = np.array(labels)
md5 = np.array(md5)

dlls_tfidf = TfidfVectorizer(min_df=0.15, max_df=0.45)
dlls_tfidf.fit(dlls_features)
dlls_tf = dlls_tfidf.transform(dlls_features)

symbols_tfidf = TfidfVectorizer(min_df=0.15,max_df=0.45)
symbols_tfidf.fit(symbols_features)
symbols_tf = symbols_tfidf.transform(symbols_features)


# csv header
h_tf = []
for i in range(0,i_dlls-1):
    h_tf.append(USED_FEATURES[i])
h_tf.append("Time")
for i in range(1,dlls_tf.shape[1]+1):
    h_tf.append("dlls"+str(i))
for i in range(1,symbols_tf.shape[1]+1):
    h_tf.append("symbols"+str(i))
h_tf.append("label")
h_tf.append("md5")
h_tf.append("ftime")

num_features = np.array(num_features)

# concatenate numerical and textual features
X_tf = concatenate_features(num_features,[dlls_tf, symbols_tf])

# normalization
normalization_tfidf = MinMaxScaler()
normalization_tfidf.fit(X_tf)
X_tf = normalization_tfidf.transform(X_tf)

gws_features = []
mws_features = []
gws_labels = []
mws_labels = []
gws_md5s = []
mws_md5s = []
gws_times = []
mws_times = []
for i in range(X_tf.shape[0]):
    if labels[i] == 0:
        gws_features.append(X_tf[i])
        gws_labels.append(labels[i])
        gws_md5s.append(md5[i])
        gws_times.append(times[i])
        # gw
    else:
        mws_features.append(X_tf[i])
        mws_labels.append(labels[i])
        mws_md5s.append(md5[i])
        mws_times.append(times[i])

#
# gws_features = X_tf[np.where(labels==0)]
# mws_features = X_tf[np.where(labels==1)]
#
# print gws_features.shape
# print mws_features.shape
#
# gws_labels = labels[np.where(labels==0)]
# mws_labels = labels[np.where(labels==1)]
#
# gws_md5s = md5s[np.where(labels==0)]
# mws_md5s = md5s[np.where(labels==1)]

gws_features = np.array(gws_features)
mws_features = np.array(mws_features)
gws_labels = np.array(gws_labels)
mws_labels = np.array(mws_labels)
gws_md5s = np.array(gws_md5s)
mws_md5s = np.array(mws_md5s)
gws_times = np.array(gws_times)
mws_times = np.array(mws_times)

n_gws = gws_features.shape[0]
n_mws = mws_features.shape[0]

# write features csv
csv_ordered = open('mw_attributes_full_sorted_alternating.csv', "w")
c_ordered = csv.writer(csv_ordered)
c_ordered.writerow(h_tf)

# iterate over mws
for i in range(n_mws):
    # write gw
    c_ordered.writerow(np.concatenate((gws_features[i % n_gws], [gws_labels[i % n_gws]], [gws_md5s[i % n_gws]], [gws_times[i % n_gws]]),axis=0))
    # write mw
    c_ordered.writerow(np.concatenate((mws_features[i], [mws_labels[i]], [mws_md5s[i]], [mws_times[i]]),axis=0))
