# -*- coding: UTF-8 -*-.
import pefile
import peutils
import commands
import hashlib
import curses.ascii
import math
import datetime
import os
#
# General Sample Attributes
## - Size
## - Hash
## - Fuzzy Hash
## - Sample Type
## - Strings
## - Entropy
# PE Header Attributes Used in Malware Analysis
#
## PE File Header
## - Machine
## - Number of Sections
## - Pointer to Symbol Table
## - Number of Symbols
## - Size of Symbols
## - Size of Optional Headers
## - Characteristics
##
## Export Directory Table (EDT)
## - Name RVA
## - Ordinal Base
## - Adress Table Entries
## - Number of Name Pointers
## - Export Address Table RVA
## - Ordinal Table RVA
##
## Import Library Table (ILT)
## - Ordinal/Name Flag
## - Ordinal Number
## - Hint/Name Table RVA
##
## Optional Headers
## - Magic
## - SizeOfCode
## - SizeOfInitilizedData
## - SizeOfUninitializedData
## - EntryPoint
## - BaseOfCode
## - BaseOfData
## - ImageBase
## - SizeOfImage
## - SizeOfHeaders
## - DLLCharacteristics
## - NumberOfRVAsAndSizes
##
## Import Directory Table (IDT)
## - Import Lookup Table RVA
## - Name RVA
## - Import Address Table RVA
##
## Load Configuration Structure
## - SecurityCookie
## - SEHandlerTable
## - SEHandlerCount
class PE:
    def __init__(self,filename,name="",strings=False):
        # ignored features
        self.ignored_features = ["getDIRECTORY_ENTRY_IMPORT", "getDOS_HEADER", "getFILE_HEADER", "getOPTIONAL_HEADER"]
        # save file name
        self.name=name
        # get PE attributes
        self.pe=pefile.PE(filename)
        # get file size
        self.size=os.path.getsize(filename)
        # get file type
        self.file_type=commands.getstatusoutput("file -b "+filename)[1]
        # get md5 and sha 1 hashes
        self.md5=self.extractMD5(filename)
        self.sha1=self.extractSHA1(filename)
        # get fuzzy hash
        self.fuzzy=commands.getstatusoutput("ssdeep -b " +filename)
        # get strings
        if strings:
            self.strings=self.extractStrings(filename)
        else:
            self.ignored_features.append("getStrings")
        # get entropy
        self.entropy=self.extractEntropy(filename)
        return
    # General Sample Attributes
    def getName(self):
        return self.name
    def getSize(self):
        return self.size
    def getFileType(self):
        return self.file_type
    def getMD5(self):
        return self.md5
    def getSHA1(self):
        return self.sha1
    def getFuzzy(self):
        return self.fuzzy
    def getStrings(self):
        return self.strings
    def getEntropy(self):
        return self.entropy
    # Dos Header
    def getDOS_HEADER(self):
        return self.pe.DOS_HEADER
    # File Header
    def getFILE_HEADER(self):
        return self.pe.FILE_HEADER
    def getMachine(self):
        return self.pe.FILE_HEADER.Machine
    def getNumberOfSections(self):
        return self.pe.FILE_HEADER.NumberOfSections
    def getTimeDateStamp(self):
        return self.pe.FILE_HEADER.TimeDateStamp
    def getFormatedTimeDateStamp(self):
        time = self.pe.FILE_HEADER.TimeDateStamp
        time = datetime.datetime.fromtimestamp(int(time))
        return time.strftime('%Y-%m-%d %H:%M:%S')
    def getPointerToSymbolTable(self):
        return self.pe.FILE_HEADER.PointerToSymbolTable
    def getNumberOfSymbols(self):
        return self.pe.FILE_HEADER.NumberOfSymbols
    def getSizeOfOptionalHeader(self):
        return self.pe.FILE_HEADER.SizeOfOptionalHeader
    def getCharacteristics(self):
        return self.pe.FILE_HEADER.Characteristics
    # Optional Header
    def getOPTIONAL_HEADER(self):
        return self.pe.OPTIONAL_HEADER
    def getMagic(self):
        return self.pe.OPTIONAL_HEADER.Magic
    def getSizeOfCode(self):
        return self.pe.OPTIONAL_HEADER.SizeOfCode
    def getSizeOfInitializedData(self):
        return self.pe.OPTIONAL_HEADER.SizeOfInitializedData
    def getSizeOfUninitializedData(self):
        return self.pe.OPTIONAL_HEADER.SizeOfUninitializedData
    # def getEntryPoint(self):
    #     return self.pe.OPTIONAL_HEADER.EntryPoint
    def getBaseOfCode(self):
        return self.pe.OPTIONAL_HEADER.BaseOfCode
    def getBaseOfData(self):
        return self.pe.OPTIONAL_HEADER.BaseOfData
    def getImageBase(self):
        return self.pe.OPTIONAL_HEADER.ImageBase
    def getSizeOfImage(self):
        return self.pe.OPTIONAL_HEADER.SizeOfImage
    def getSizeOfHeaders(self):
        return self.pe.OPTIONAL_HEADER.SizeOfHeaders
    def getDllCharacteristics(self):
        return self.pe.OPTIONAL_HEADER.DllCharacteristics
    def getFileAlignment(self):
        return self.pe.OPTIONAL_HEADER.FileAlignment
    def getNumberOfRvaAndSizes(self):
        return self.pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
    # PE Type
    def getPE_TYPE(self):
        return self.pe.PE_TYPE
    # Directory Entry Import
    def getDIRECTORY_ENTRY_IMPORT(self):
        return self.pe.DIRECTORY_ENTRY_IMPORT
    def getImportedDlls(self):
        return [d.dll for d in self.getDIRECTORY_ENTRY_IMPORT()]
    def getImportedSymbols(self):
        symbols = []
        for i in self.getDIRECTORY_ENTRY_IMPORT():
            for s in i.imports:
                if s.name != None:
                    symbols.append(s.name)
        return symbols
    # Directory Entry Export
    # def getDIRECTORY_ENTRY_EXPORT(self):
    #     return self.pe.DIRECTORY_ENTRY_EXPORT
    # Signaturues: packer/compiler/tools/etc
    def getIdentify(self):
        # Load PE Signature Database & Sample PE
        db_path = "peid_userdb.txt"
        sigs=peutils.SignatureDatabase(data=open(db_path, 'rb').read())
        # Match PE against signature database
        matches=sigs.match_all(self.pe, ep_only=True)
        return matches
    # return all valid methods for feature extraction
    def fe_methods(self):
        features=[]
        for i in dir(self):
            method = getattr(self, i)
            if i.startswith('get') and hasattr(method, '__call__') and i not in self.ignored_features:
                features.append(i.replace("get",""))
        return features
    def fe_values(self):
        values = []
        for i in dir(self):
            method = getattr(self, i)
            if i.startswith('get') and hasattr(method, '__call__') and i not in self.ignored_features:
                values.append(method())
        return values
    # util methods
    def extractMD5(self, filename):
        data=open(filename, "r").read()
        return hashlib.md5(data).hexdigest()
    def extractSHA1(self, filename):
        data=open(filename, "r").read()
        return hashlib.sha1(data).hexdigest()
    def extractStrings(self,filename):
        frag=""
        strList=[]
        bufLen=2048
        FRAG_LEN=4 # Min length to report as string

        fp=open(filename, "rb")

        offset=0
        buf=fp.read(bufLen)
        while buf:
            for char in buf:
                # Uses curses library to locate printable chars
                # in binary files.
                if curses.ascii.isprint(char)==False:
                    if len(frag)>FRAG_LEN:
                        # strList.append([hex(offset-len(frag)),frag])
                        strList.append(frag)
                    frag=""
                else:
                    frag=frag+char

                offset+=1
            buf=fp.read(bufLen)
        return strList
    def extractEntropy(self, filename):
        data=open(filename, "r").read()
        if not data:
            return 0
        entropy=0
        for x in range(256):
            p_x = float(data.count(chr(x)))/len(data)
            if p_x>0:
                entropy += - p_x*math.log(p_x, 2)
        return entropy
